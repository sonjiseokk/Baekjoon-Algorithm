# 문제
# 666이 들어가는 숫자를 정렬하여 입력받은 수 번째 값을 출력하는 프로그램.

# 조건
# 1. n은 10000까지 주어진다.
# 2. 6660 ~ 6669 와 1666~9666 이런걸 모두 고려해야 한다.

# 복기
# 1. 처음엔 밑의 주석과 같이 문제를 풀었더니 정답 처리가 되었다;;
# 2. 다만 이건 브루트포스 방식과 맞긴 하지만 성능 문제가 상당하다. for문을 다 때려박기 때문이다.

"""
n = int(input())

death = []
for i in range(10000000):
    temp = str(i)
    if temp.find('666') != -1:
        death.append(int(temp))

death.sort()
print(death[n-1])
"""

# 풀이
# 1. 이전에 for문을 무지성으로 때려박아서 리스트를 전부 완성시키던 느낌이 아니라 필요한 만큼만 숫자를 늘리기로 하였다.
# 2. 일단 시작을 666으로 시작하였고, 그 값 안에 666이 있다면 카운트를 증가시켜 n만큼만 찾도록 최적화 하였다.
# 3. 다만 num을 1씩 증가시켜서 찾는다는 방식은 동일하다. 브루트포스의 매력~

n = int(input())
count = 0
num = 666
while True:
    if '666' in str(num):
        count += 1
    if count == n:
        print(num)
        break
    num += 1


        